## 
###1
 - 不使用 wait()/notify() 如何实现线程之间通信？

   创建2个线程，2个线程中放入同一对象，A中遍历添加元素到集合中，B中用while来执行死循环获取当集合长度为多少时抛出异常。这是简单的一个案例。
 
 - 等待/通知机制实现
 
    通过 wait()/notify() 。他们都是 Object 类的方法。
    1. wait()
    
    - 使线程停止运行
    - 只能在同步方法或者同步代码快中执行
    - wait() 执行后，释放当前对象锁。执行前没有合适锁对象，会抛出异常。
    2. notify()
    - 使停止的线程继续运行
    - 只能在同步方法或者同步代码快中执行
    - 执行前没有合适锁对象，会抛出异常,执行后，只有退出了synchronized方法后才会释放当前对象锁。
    3. 当线程数很多的时候，用notifyAll()唤醒所有线程
    4. wait(long) 在某个时间内是否有线程对其唤醒，否则超时自动唤醒.
    5. 如果通知过早，会影响逻辑性(但是线程启动不是有随机性嘛，小概率事件会正常，不过我运行很多次都是影响的，囧)
    
    - 等待/通知机制的经典案例--生产者/消费者模式   
    
    1. 多生产者-多消费者：假死
    
    原因：有可能notify()唤醒的是同类，积少成多，造成假死
    
    解决：将异类一起唤醒即可，使用notifyAll()
    
    2. 解决wait()条件改变与假死
    
    原因：多个线程在wait后重新执行时，后面的操作异常导致。
    解决：使用while
 
 - 通过管道实现进程间通信 
    - pipeSteam:同于在不同线程间直接传送数据。
    1. 字节流-PipedInputStream/PipedOutputStream
    2. 字符流-PipedReader/PipedWriter
    
### 2 
 - join() 等待线程对象的销毁
 
 场景：当需求是要在子线程操作一个数据，主线程需要获取这个值。
 
 
 
 
 
 
 
 
 
 
 
 
 